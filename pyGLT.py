import numpy
import sys
import cv2
import os
import struct

IMAGE_COUNT = 0x4
IMAGE_BEGIN_PTR = 0x10

# relative
TO_NEXT_IMG = 4
TO_ENC = 0x5
TO_WIDTH = 0x4
TO_IMG = 0xE

cc38 = [
         0x00,0x24,0x49,0x6d, 0x92,0xb6,0xdb,0xff

]

cc48 = [     0x00,0x11,0x22,0x33, 0x44,0x55,0x66,0x77, 0x88,0x99,0xaa,0xbb, 0xcc,0xdd,0xee,0xff
]

cc58 =[
	    0x00,0x08,0x10,0x19, 0x21,0x29,0x31,0x3a, 0x42,0x4a,0x52,0x5a, 0x63,0x6b,0x73,0x7b,
	    0x84,0x8c,0x94,0x9c, 0xa5,0xad,0xb5,0xbd, 0xc5,0xce,0xd6,0xde, 0xe6,0xef,0xf7,0xff
]
	
cc68 =[
		    0x00,0x04,0x08,0x0c, 0x10,0x14,0x18,0x1c, 0x20,0x24,0x28,0x2d, 0x31,0x35,0x39,0x3d,
		    0x41,0x45,0x49,0x4d, 0x51,0x55,0x59,0x5d, 0x61,0x65,0x69,0x6d, 0x71,0x75,0x79,0x7d,
		    0x82,0x86,0x8a,0x8e, 0x92,0x96,0x9a,0x9e, 0xa2,0xa6,0xaa,0xae, 0xb2,0xb6,0xba,0xbe,
		    0xc2,0xc6,0xca,0xce, 0xd2,0xd7,0xdb,0xdf, 0xe3,0xe7,0xeb,0xef, 0xf3,0xf7,0xfb,0xff
]

cc83 =[
	         0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	         0x00,0x00,0x00,0x01, 0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01,
	         0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01,
	         0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x02, 0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02,
	         0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02,
	         0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02, 0x03,0x03,0x03,0x03,
	         0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03,
	         0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03,
	         0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04,
	         0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04,
	         0x04,0x04,0x04,0x04, 0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05,
	         0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05,
	         0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x06,0x06,0x06, 0x06,0x06,0x06,0x06,
	         0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06,
	         0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06, 0x06,0x07,0x07,0x07,
	         0x07,0x07,0x07,0x07, 0x07,0x07,0x07,0x07, 0x07,0x07,0x07,0x07, 0x07,0x07,0x07,0x07
	     ]

cc84 =[
	         0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x01,0x01,0x01, 0x01,0x01,0x01,0x01,
	         0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01, 0x01,0x01,0x02,0x02, 0x02,0x02,0x02,0x02,
	         0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x03, 0x03,0x03,0x03,0x03,
	         0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x04,0x04,0x04,0x04,
	         0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04, 0x04,0x05,0x05,0x05,
	         0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x05,0x06,0x06,
	         0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x07,
	         0x07,0x07,0x07,0x07, 0x07,0x07,0x07,0x07, 0x07,0x07,0x07,0x07, 0x07,0x07,0x07,0x07,
	         0x08,0x08,0x08,0x08, 0x08,0x08,0x08,0x08, 0x08,0x08,0x08,0x08, 0x08,0x08,0x08,0x08,
	         0x08,0x09,0x09,0x09, 0x09,0x09,0x09,0x09, 0x09,0x09,0x09,0x09, 0x09,0x09,0x09,0x09,
	         0x09,0x09,0x0a,0x0a, 0x0a,0x0a,0x0a,0x0a, 0x0a,0x0a,0x0a,0x0a, 0x0a,0x0a,0x0a,0x0a,
	         0x0a,0x0a,0x0a,0x0b, 0x0b,0x0b,0x0b,0x0b, 0x0b,0x0b,0x0b,0x0b, 0x0b,0x0b,0x0b,0x0b,
	         0x0b,0x0b,0x0b,0x0b, 0x0c,0x0c,0x0c,0x0c, 0x0c,0x0c,0x0c,0x0c, 0x0c,0x0c,0x0c,0x0c,
	         0x0c,0x0c,0x0c,0x0c, 0x0c,0x0d,0x0d,0x0d, 0x0d,0x0d,0x0d,0x0d, 0x0d,0x0d,0x0d,0x0d,
	         0x0d,0x0d,0x0d,0x0d, 0x0d,0x0d,0x0e,0x0e, 0x0e,0x0e,0x0e,0x0e, 0x0e,0x0e,0x0e,0x0e,
	         0x0e,0x0e,0x0e,0x0e, 0x0e,0x0e,0x0e,0x0f, 0x0f,0x0f,0x0f,0x0f, 0x0f,0x0f,0x0f,0x0f
	     ]



cc85 = [
		    0x00,0x00,0x00,0x00, 0x00,0x01,0x01,0x01, 0x01,0x01,0x01,0x01, 0x01,0x02,0x02,0x02,
		    0x02,0x02,0x02,0x02, 0x02,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x03,0x04,0x04,0x04,
		    0x04,0x04,0x04,0x04, 0x04,0x04,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x05,0x06,0x06,
		    0x06,0x06,0x06,0x06, 0x06,0x06,0x07,0x07, 0x07,0x07,0x07,0x07, 0x07,0x07,0x08,0x08,
		    0x08,0x08,0x08,0x08, 0x08,0x08,0x09,0x09, 0x09,0x09,0x09,0x09, 0x09,0x09,0x09,0x0a,
		    0x0a,0x0a,0x0a,0x0a, 0x0a,0x0a,0x0a,0x0b, 0x0b,0x0b,0x0b,0x0b, 0x0b,0x0b,0x0b,0x0c,
		    0x0c,0x0c,0x0c,0x0c, 0x0c,0x0c,0x0c,0x0d, 0x0d,0x0d,0x0d,0x0d, 0x0d,0x0d,0x0d,0x0d,
		    0x0e,0x0e,0x0e,0x0e, 0x0e,0x0e,0x0e,0x0e, 0x0f,0x0f,0x0f,0x0f, 0x0f,0x0f,0x0f,0x0f,
		    0x10,0x10,0x10,0x10, 0x10,0x10,0x10,0x10, 0x11,0x11,0x11,0x11, 0x11,0x11,0x11,0x11,
		    0x12,0x12,0x12,0x12, 0x12,0x12,0x12,0x12, 0x12,0x13,0x13,0x13, 0x13,0x13,0x13,0x13,
		    0x13,0x14,0x14,0x14, 0x14,0x14,0x14,0x14, 0x14,0x15,0x15,0x15, 0x15,0x15,0x15,0x15,
		    0x15,0x16,0x16,0x16, 0x16,0x16,0x16,0x16, 0x16,0x16,0x17,0x17, 0x17,0x17,0x17,0x17,
		    0x17,0x17,0x18,0x18, 0x18,0x18,0x18,0x18, 0x18,0x18,0x19,0x19, 0x19,0x19,0x19,0x19,
		    0x19,0x19,0x1a,0x1a, 0x1a,0x1a,0x1a,0x1a, 0x1a,0x1a,0x1b,0x1b, 0x1b,0x1b,0x1b,0x1b,
		    0x1b,0x1b,0x1b,0x1c, 0x1c,0x1c,0x1c,0x1c, 0x1c,0x1c,0x1c,0x1d, 0x1d,0x1d,0x1d,0x1d,
		    0x1d,0x1d,0x1d,0x1e, 0x1e,0x1e,0x1e,0x1e, 0x1e,0x1e,0x1e,0x1f, 0x1f,0x1f,0x1f,0x1f
		]
	 
cc86 = [
			    0x00,0x00,0x00,0x01, 0x01,0x01,0x01,0x02, 0x02,0x02,0x02,0x03, 0x03,0x03,0x03,0x04,
			    0x04,0x04,0x04,0x05, 0x05,0x05,0x05,0x06, 0x06,0x06,0x06,0x07, 0x07,0x07,0x07,0x08,
			    0x08,0x08,0x08,0x09, 0x09,0x09,0x09,0x0a, 0x0a,0x0a,0x0a,0x0b, 0x0b,0x0b,0x0b,0x0c,
			    0x0c,0x0c,0x0c,0x0d, 0x0d,0x0d,0x0d,0x0e, 0x0e,0x0e,0x0e,0x0f, 0x0f,0x0f,0x0f,0x10,
			    0x10,0x10,0x10,0x11, 0x11,0x11,0x11,0x12, 0x12,0x12,0x12,0x13, 0x13,0x13,0x13,0x14,
			    0x14,0x14,0x14,0x15, 0x15,0x15,0x15,0x15, 0x16,0x16,0x16,0x16, 0x17,0x17,0x17,0x17,
			    0x18,0x18,0x18,0x18, 0x19,0x19,0x19,0x19, 0x1a,0x1a,0x1a,0x1a, 0x1b,0x1b,0x1b,0x1b,
			    0x1c,0x1c,0x1c,0x1c, 0x1d,0x1d,0x1d,0x1d, 0x1e,0x1e,0x1e,0x1e, 0x1f,0x1f,0x1f,0x1f,
			    0x20,0x20,0x20,0x20, 0x21,0x21,0x21,0x21, 0x22,0x22,0x22,0x22, 0x23,0x23,0x23,0x23,
			    0x24,0x24,0x24,0x24, 0x25,0x25,0x25,0x25, 0x26,0x26,0x26,0x26, 0x27,0x27,0x27,0x27,
			    0x28,0x28,0x28,0x28, 0x29,0x29,0x29,0x29, 0x2a,0x2a,0x2a,0x2a, 0x2a,0x2b,0x2b,0x2b,
			    0x2b,0x2c,0x2c,0x2c, 0x2c,0x2d,0x2d,0x2d, 0x2d,0x2e,0x2e,0x2e, 0x2e,0x2f,0x2f,0x2f,
			    0x2f,0x30,0x30,0x30, 0x30,0x31,0x31,0x31, 0x31,0x32,0x32,0x32, 0x32,0x33,0x33,0x33,
			    0x33,0x34,0x34,0x34, 0x34,0x35,0x35,0x35, 0x35,0x36,0x36,0x36, 0x36,0x37,0x37,0x37,
			    0x37,0x38,0x38,0x38, 0x38,0x39,0x39,0x39, 0x39,0x3a,0x3a,0x3a, 0x3a,0x3b,0x3b,0x3b,
			    0x3b,0x3c,0x3c,0x3c, 0x3c,0x3d,0x3d,0x3d, 0x3d,0x3e,0x3e,0x3e, 0x3e,0x3f,0x3f,0x3f
			]

f = []
path = ""

class NLGImage:
    hash = 0
    offset = 0
    size = 0
    mip = 0
    enc = 0
    w = 0
    h = 0
    buf = []
    
    def __str__(self):
        return f"hash: {self.hash:x}\noffset:{self.offset:x}\nsize: {self.size:x}\nmip: {self.mip}\nenc: {self.enc:x}\nwidth: {self.w}\nheight: {self.h}"
    
    

def to_int(byt):
    return int.from_bytes(byt,byteorder="big",signed = False)

def readInt():
    return to_int(f.read(0x4))
def readShort():
    return to_int(f.read(0x2))
def readByte():
    return to_int(f.read(0x1))

def advance(offset):
    f.seek(f.tell()+offset)
    
def oadvance(o,offset):
    o.seek(o.tell()+offset)
        
def to888(color):
    r = (color >> 11) & 0x1F
    g = (color >> 5) & 0x3F
    b = color & 0x1F
    
    r = cc58[r]
    g = cc68[g]
    b = cc58[b]
    return (r, g, b)

def to888c(color):
    r = (color >> 11) & 0x1F
    g = (color >> 5) & 0x3F
    b = color & 0x1F
    
    r = cc58[r]
    g = cc68[g]
    b = cc58[b]
    return 0xff << 24 | r << 16 | g << 8 | b

def colorMul(r0, g0, b0, r1, g1, b1, m1, m2):
    r2 = int(r0 * m1 + r1 * m2)
    g2 = int(g0 * m1 + g1 * m2)
    b2 = int(b0 * m1 + b1 * m2)

    r2 = max(0, min(255, r2))
    g2 = max(0, min(255, g2))
    b2 = max(0, min(255, b2))

    return 0xff << 24 | (r2 << 16) | (g2 << 8) | b2
    

def c2c3(c0,c1):
    alpha = False
    if(c0<c1):
        alpha = True

    r0,g0,b0 = to888(c0)
    r1,g1,b1 = to888(c1)   
    
    c2 = 0
    c3 = 0
    
    if(alpha):
        c2 = colorMul(r0,g0,b0,r1,g1,b1,1/2,1/2)
        c3 = 0
    else:
        c2 = colorMul(r0,g0,b0,r1,g1,b1,2/3,1/3)
        c3 = colorMul(r0,g0,b0,r1,g1,b1,1/3,2/3)
    
    return c2,c3


def writeImage(hash,enc,img): 
    os.makedirs(path, exist_ok=True)
    cv2.imwrite(path+"//"+hex(hash)[2:]+"_enc_"+str(enc)+".png", img)
    print(f"Wrote {hash}.png to {path}/")
       
        
pattern =[[0,0],[0,1],[1,0],[1,1]] 

def extractImageCMPR(n,img):
    for ii in range(0,int(n.h/8)):
        for jj in range(0,int(n.w/8)):
            for k in range(0,4):
                indices = []
                palette =[]
                
                c0 = readShort()
                c1 = readShort()
                c2,c3 = c2c3(c0,c1)
                
                #if(c0<c1):
               #     print(c0,c1)
                
                c0 = to888c(c0)
                c1 = to888c(c1)
                

                
                palette = [c0,c1,c2,c3]
                
                indices32 = readInt()
                        
                for i in range(0,16):
                    indices.append((indices32 >> 30-(2*i)) & 0b11)
                

        


                for i in range(0,4):
                    for j in range(0,4):
                            #print(i + ii*8 + pattern[k][0]*4,j + jj*8 + pattern[k][1]*4 )
                            pixel = []
                            for p in range(0,4):
                                pixel.append(((palette[indices[j + i*4]])>>(24-(8*p)))&0xff) 
                            #print(pixel) 

                            img[i + ii*8 + pattern[k][0]*4,j + jj*8 + pattern[k][1]*4] = (pixel[3],pixel[2],pixel[1],pixel[0])
    writeImage(n.hash,n.enc,img)



def to888From5a3(color, alpha):
    if(alpha):  #0AAARRRRGGGGBBBB
        ret = cc38[(color>>12) &7] <<24 | cc48[((color >> 8) & 0xF)] <<16 |  cc48[((color >> 4) & 0xF)] << 8 | cc48[color & 0xF]
	
	 
    else:      #1RRRRRGGGGGBBBBB
      ret = (0xFF<<24) | (cc58[((color >> 10) & 0x1F)] <<16) |  (cc58[((color >> 5) & 0x1F)] << 8) | cc58[color & 0x1F]
	 
    return ret

def extractImageRGB5a3(n,img):
    for ii in range(0,int(n.h/4)):
        for jj in range(0,int(n.w/4)):
            for i in range(0,4):
                for j in range(0,4):
                               
                    color = readShort() 
                    if(((color >> 15) & 0x1) == 0x1):
                        color = to888From5a3(color, False)
                    else:
                        color = to888From5a3(color, True)
                        
                    pixel = []
                    for p in range(0,4):
                        pixel.append((color>>(24-(8*p)))&0xff)
                    #print(pixel) 
                   # print(n.h,n.w,ii*4+i,jj*4+j)
                    img[ii*4+i,jj*4+j] = (pixel[3],pixel[2],pixel[1],pixel[0])
    writeImage(n.hash,n.enc,img)

          
    
def extractImage(n):
    img = numpy.zeros((n.h, n.w, 4), dtype=numpy.uint8)
    
    if(n.enc==0x6):
        extractImageCMPR(n,img)
    elif(n.enc==0x5):
        extractImageRGB5a3(n,img)
            



        
def closest(pixel,pal):
    closest = 0xffffffff
    for i in range(0,len(pal)):
        temp = abs(pixel-pal[i])
        if(temp<closest):
            closest = temp
            ci = i
    return ci



def toU32(color):
        return (((color[2]&0xff)<<16) | ((color[1]&0xff) << 8) | (color[0]&0xff))&0xffffff

def to565(color):
    return 	(cc85[ (color >> 16) & 0xff ]<<11) | (cc86[ (color >>  8) & 0xff ] <<  5) | (cc85[ color       & 0xff ]);       

def minmax(texel):
    c0=0
    c1 = 0xffffffff
    for row in texel:
        for pixel in row:
            color = (toU32(pixel))
            if(color>c0):
                c0=color
            if(color<c1):
                c1 = color
        #quit()
    return c0,c1

def encodeCMPR(ibuf,n):
    
    n.buf = []
    alpha = False
    _alpha = []
    if ibuf.shape[2] == 4:
        _alpha = ibuf[:, :, 3]
    _alpha = numpy.array(_alpha)

    if numpy.any(_alpha < 0x80):
        alpha = True

    pal = [0,0,0,0]
    tex_cnt = 0
    
    for ii in range(0,int(n.h/8)):
        for jj in range(0,int(n.w/8)):
            for k in range(0,4):
                
                texel = ibuf[ii*8 + pattern[k][0]*4:4 + ii*8 + pattern[k][0]*4, jj*8 + pattern[k][1]*4:4 + jj*8 + pattern[k][1]*4]
                indices = []
                indexu32 = 0
                
                if(alpha):
                    c1,c0 = minmax(texel)
                    pal[0] = c0
                    pal[1] = c1
                    if(pal[0]==pal[1]):
                        pal[1]+=1

                else:

                    c0,c1 = minmax(texel)
                    
                    if(to565(c0)<to565(c1)):
                        temp = c1
                        c1 = c0
                        c0 = temp

                    pal[0] = c0
                    pal[1] = c1
                    
                
                    
                pal[2] = ((2*pal[0]+pal[1])/3)
                pal[3] = ((pal[0]+2*pal[1])/3)
                
                
                for i in range(0,4):
                    for j in range(0,4):
                        indices.append(closest(toU32(texel[i,j]),pal))
                        
                for i in range(0,len(indices)):
                    indexu32 += (indices[i]&3) << (30-(i*2))
                    
                c0565 = to565(c0)
                c1565 = to565(c1)
                          
                    
                c0_buf = struct.pack('>H',c0565)
                c1_buf = struct.pack('>H',c1565)
                in_buf = struct.pack('>I',indexu32)
                n.buf+=c0_buf
                n.buf+=c1_buf
                n.buf+=in_buf
                tex_cnt+=1
                
    n.size = len(n.buf)+0x20
    #print("tex",tex_cnt,hex(n.size),ibuf.shape[0],ibuf.shape[1])


def to5a3From888(c, alpha):
    
    argb = [c[0],c[3],c[2],c[1]]
    
    if(not alpha):
        a= 0x1
        r = cc85[(argb[2])&0xff]
        g = cc85[(argb[1])&0xff]
        b = cc85[(argb[0])&0xff]
        ret = (a<<15) | r <<10 | g<<5 | b
    else:
        a = cc83[(argb[3])&0xff]
        r = cc84[(argb[2])&0xff]
        g = cc84[(argb[1])&0xff]
        b = cc84[(argb[0])&0xff]
            
        ret = (0x0 << 15)&0x7 | a<< 12 | r <<8 | g<<4 | b
        
        return ret

           
def encodeRGB5a3(ibuf,n):
    buf = []
    for ii in range(0,int(n.h/4)):
        for jj in range(0,int(n.w/4)):
            
            texel = ibuf[ii*4:(ii*4)+4 ,jj*4:(jj*4)+4]
            for i in range(0,4):
                for j in range(0,4):     
                    if texel[i,j][0]& 0xFF >= 0x80:
                        color = to5a3From888(texel[i,j], False)
                    else:
                        color = to5a3From888(texel[i,j], True)
                    if(color):
                        buf+= struct.pack(">H",color)
    while(len(buf)%0x10!=0):
        buf+= struct.pack("B",0)
    n.size = len(buf)+0x20
    n.buf = buf
                
                
def writeEmpty(o,end):
   while(o.tell() < end):
       o.write(b'\x00')                 
                
                
                
def decode():
    advance(IMAGE_COUNT)
    imageCount = readInt()

    f.seek(IMAGE_BEGIN_PTR)
    NLGImages = []



    # read header image table
    for i in range(0,imageCount):
        n = NLGImage()
        n.hash = readInt()
        n.offset = readInt()
        n.size = readInt()
        NLGImages.append(n)
        advance(TO_NEXT_IMG)
        #print(n.size)       

    start_offset = f.tell()
    # read individual image headers
    for n in NLGImages:
        f.seek(start_offset)
        advance(n.offset)
        #buf = f.read(0x20)
        #print(hex(f.tell() - 0x20), buf)
        #advance(-0x20)
        n.mip = readInt()
        advance(TO_ENC)
        n.enc = readByte()
        advance(TO_WIDTH)
        n.w = readShort()
        n.h = readShort()
        advance(TO_IMG)
        extractImage(n)  

def encodeImage(ibuf,n):
    
    if(n.enc==0x5):
        encodeRGB5a3(ibuf,n)
    elif(n.enc==0x6):
        encodeCMPR(ibuf,n)
   

def encode():
    offset = 0
    nimg = []
    images = [f for f in os.listdir(path) if f.endswith(".png")]
    
    for image in images:
        n = NLGImage()
        n.size = 0
        tbuf = cv2.imread(path+"/"+image,cv2.IMREAD_UNCHANGED)
        nstr = image.split('_')
        n.hash = int(nstr[0],16)
        n.enc = int(nstr[2][0])
        n.w = tbuf.shape[1]
        n.h = tbuf.shape[0]
        encodeImage(tbuf,n)
        nimg.append(n)
        print("image "+image+" done.")
   
    out = open(path+"/"+path+".rlt",'wb')
    out.write("PTLG".encode('utf-8'))
    out.write(struct.pack(">I",len(nimg)))
    out.write("pyGLT".encode('utf-8'))

    
    # write image table
    writeEmpty(out,IMAGE_BEGIN_PTR)    
    for n in nimg:
        out.write(struct.pack(">I",n.hash))
        out.write(struct.pack(">I",offset))
        offset+=n.size 
        #print("offset: ",offset)  
        out.write(struct.pack(">I",n.size))
        if(n.enc==0x6):
            out.write('CMPR'.encode('utf=8'))
        elif(n.enc==0x5):
            out.write('RGB5'.encode('utf=8'))
        #oadvance(out,TO_NEXT_IMG)
        
    # write images
    for n in nimg:
        writeEmpty(out,out.tell()+3)
        out.write(b'\x01')
        writeEmpty(out,out.tell()+3)
        
        if(n.enc==0x6):
            out.write(b'\x02')
            out.write(b'\x05')
            out.write(b'\x06')
            out.write(b'\x05')
            writeEmpty(out,out.tell()+3)
            
        elif(n.enc==0x5):
            out.write(b'\x01')
            out.write(b'\x05')
            out.write(b'\x05')
            out.write(b'\x05')
            out.write(b'\x03')    
            writeEmpty(out,out.tell()+2)
        
        out.write(struct.pack('>H',n.w))
        out.write(struct.pack('>H',n.h))
        
        writeEmpty(out,out.tell()+TO_IMG)
        out.write(bytes(n.buf))
    quit()  
    

        
    
   
    
    
    
    
    
    
if len(sys.argv)  ==0:
    print("no args. exiting.")
    quit()  
    
fname = sys.argv[1]
f = open(fname,mode="rb")
path = os.path.splitext(fname)[0]
print(path)
_encode = False
if(len(sys.argv)>=2):
    _encode = sys.argv[2] == 'enc'


if _encode:
    encode()
decode()


    
